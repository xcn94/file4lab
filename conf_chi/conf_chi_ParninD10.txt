In order to resume incomplete programming tasks, developers must recall their previous working state and refresh their knowledge of the software and tasks.
Details of working state include plans, intentions, and goals; details of knowledge include relevant artifacts, component mechanisms, and domain representations.
Unfortunately, the nature of the knowledge and program artifacts does not make this process any easier.
First, much knowledge used for the programming task is tacit and ephemeral.
Therefore, an interruption can be detrimental to retaining this type of knowledge.
Second, a software program, unlike a novel or television series, does not have a simple linear structure - a recap or rescanning the last few paragraphs of text is not enough to allow the developer to resume work.
Instead, the relevant information exists across various artifacts and locations and must be actively sought and restored in the mind.
Developers are certainly not alone in facing problems with interruptions.
Several psychological studies of simple tasks and observational studies of knowledge workers have characterized the effects of interruptions on people.
Researchers have characterized the effects on performance  and mental fatigue  as well as understanding the contribution of interruption frequency  and interruption length, task similarity, and complexity  on performance.
Despite efforts for managing interruptions, in situ studies suggest interruptions remain problematic.
Czerwinski's study  showed that tasks resumed after an interruption were more difficult to perform and took twice as long.
O'Conaill's study  found 40% of interrupted tasks are not resumed at all.
Further research by Mark et al.
In a field study of 27 people, Iqbal and Horvitz  found that people had difficulty in recovering state from suspended tasks due to loss of context and low visibility of suspended windows.
Studies examining software companies have replicated similar results from previous workplace studies.
Solingen  characterizes interruptions at several industrial software companies and observed that an hour a day was spent managing interruptions, and developers typically required 15 minutes to recover from an interruption.
Parnin and Rugaber  analyzed interaction logs from 10,000 pro-
Developers, like all modern knowledge workers, are frequently interrupted and blocked in their tasks.
In this paper we present a contextual inquiry into developers' current strategies for resuming interrupted tasks and investigate the effect of automated cues on improving task resumption.
We surveyed 371 programmers on the nature of their tasks, interruptions, task suspension and resumption strategies and found that they rely heavily on note-taking across several types of media.
We then ran a controlled lab study to compare the effects of two different automated cues to note taking when resuming interrupted programming tasks.
The two cues differed in  whether activities were summarized in aggregate or presented chronologically and  whether activities were presented as program symbols or as code snippets.
Both cues performed well: developers using either cue completed their tasks with twice the success rate as those using note-taking alone.
Despite the similar performance of the cues, developers strongly preferred the cue that presents activities chronologically as code snippets.
Professional developers must frequently resume unfinished programming tasks from where they left off.
The interruptions may be due to unexpected requests from co-workers, scheduled meetings, or task blockages due to unavailable colleagues or resources.
Regardless of the source, the effects are often the same: When resuming work, developers experience increased time to perform the task, increased errors, increased loss of knowledge, and increased failure to remember to perform critical tasks.
To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee.
At the start of each session, a programmer often spends a significant amount of time rebuilding working context before resuming coding.
To resume an interrupted task, a programmer needs to recover both the task's working context  and her mental context .
There has been a considerable line of research, summarized below, to discover and organize the working contexts that comprise a knowledge worker's tasks and provide visual cues for assisting recovery from interruptions.
The hope is that if a tool is able to persist the working context and provide visual cues, when a task is resumed the user will have an easier time recovering the corresponding mental state.
Of these, Mylyn , has emerged to become an integrated feature of the Eclipse development environment and a standard for representing task context.
Researchers propose that maintaining task context would help reduce mental workload during development .Although there is some evidence these task context tools reduce navigation cost for programmers , these tools have yet not been evaluated with interrupted programming tasks.
With an interrupted programming task, these tools may be reducing workspace clutter, but not supporting recovery of mental context.
In this paper, we investigate how programming environments can be enhanced to assist developers when resuming interrupted programming tasks.
First, we surveyed 371 developers to learn about their current habits for coping with interruption and their preferences for potential treatments to help them recover from interruption.
We then ran a controlled study looking at the effect of three different interruption recovery conditions on task completion and errors.
Our base condition, note taking, represents the most prevalent existing practice for preserving mental state, based on our preliminary study.
The other two conditions represent different automated cues, which the subjects could combine with note taking.
The first automated cue replicates Mylyn's design; the second integrates the most highly rated features from our preliminary study.
Taking prospective measures at the time of interruption has both negative and positive effects  on task resumption.
When comparing written notes versus mental notes, written notes were found to be effective in assisting recall, but negatively effected the ability to recall contextual details about the task when compared to mental notes.
With external interruptions such as an email notification, there are several strategies for negotiating the moment of interruption, often referred to as the breakpoint.
McFarlane has evaluated and compared the different strategies for setting a breakpoint: immediately addressed interruption, scheduled , negotiated , mediated  .
In our controlled study, we focus our on negotiated  which are common in software development .
Miyata and Norman  suggest that people seek breakpoints at moments where the current task requires low mental workload.
Indeed, studies of interrupted tasks such as document editing or route planning have demonstrated that breakpoints at moments of higher mental workload cause longer resumption lag than breakpoints at lower mental workload .
A less disruptive interruption arose when the breakpoint could be delayed by a few seconds.
In the experiment, programmers were interrupted every 3 minutes with a multiplication problem.
The programmer had the choice to delay addressing the interruption until a good breakpoint was reached.
For most interruptions, the programmers would address the interruption within 10 seconds; however, when more deeply engaged, they would defer for a mean of 43 seconds.
The nature of an interruption is an important determinate on the extent of the interruption's impact.
The worst type of interruption often comes at an inopportune moment and gives insufficient time to a programmer for preserving mental working state.
These inopportune moments tend to align with programmers using large amounts of intermediate knowledge that does not yet have any physical representation nor have a firm foothold in the programmer's mind.
Programmers can mitigate the effects of interruption by taking prospective measures before addressing the interruption.
The interruption lag  describes the time between when the user stop working on a task and when they begin ad-
Recent research has identified a strong connection between internalizing environmental cues and reducing resumption costs .
In these experiments, the availability of cues during task resumption reduces the time to restart the task.
Conversely, if the cue is removed or tampered with, then this benefit is removed.
This even holds for implicit cues such as the location of a mouse cursor.
For example, in one experiment when the mouse cursor location was moved from hovering over the last button clicked to be in the corner of the screen, the resulting resumption lag was higher than when the implicit cue was present.
Observations of developers suggest they frequently rely on cues for maintaining context during programming.
For example, Ko et al.
Navigation jitter has been commonly attributed to developers flipping through open tabs and file lists when trying to recall a location .
Environmental cues such as open tabs may be insufficient because what a developer remembers may be spatial and textual cues within the code document  and not the semantic or structural location of the code element when automatically encoding working state .
An initial experiment by Safer and Murphy  supports the insufficiency of semantic-based cues: Using a screenshot-based cue, users were able to identify details about recently performed tasks quicker and with less errors than with a semantic-based cue.
These approaches focus on reducing the clutter associated with the mixed landscape of the computing desktop.
Group Bar  allows users to organize windows and documents located in the task bar of Windows OS into similar groups based on their tasks.
Other tools such as CAAD , attempt to do this automatically by clustering related work items based on interaction coupling.
Rather than organize the documents and windows into definitive task categories, another approach allows users to associate personal tags with documents and activities  or shared work items .
For programmers, Mylyn 1 , a tool available with Eclipse, allows users to filter code documents based on a selected task and recent interaction history.
Another direction of research has investigated various ways of augmenting temporal, spatial, and contextual cues in the environment.
Scalable Fabric  using a zoomable organization of windows and documents to leverage spatial memory for facilitating task switching.
A similar effort has been made for viewing source code through Code Thumbnails .
Window Scape  introduced temporal snapshots of windows where users can return to recent contexts.
In a study of searching open documents and windows , the researchers found improved performance for switching between interrupted tasks by introducing temporal and object similarity cues to the preview windows of the Alt-Tab interface of Windows OS.
Successful organization of work items through tools can reduce the friction between switched tasks; however, we believe it does not fully address the problems of recovering lost working state.
Other than Mylyn, previous resumption aids have not taken advantage of the structure of the task content.
That is, previous treatments focus on the gross-level structure of the tasks - windows and documents - not the fine-level structure of the task - methods or lines of code.
Finally, many designs have been proposed, but few evaluate their performance on recovering from interruptions, especially knowledge-intensive tasks like programming.
In this paper, we are concerned with evaluating the role and performance of resumption aids on interrupted programming tasks.
Researchers have investigated how information workers manage general tasks for insights into improving task management.
Bellotti  studied the various media employed by 9 different managers and found in addition to using paper media such as sticky notes - 50% of the tasks could be linked to emails.
Brush  observed 8 workers who needed to frequently file status reports of their weekly activity.
5 out of the 8 workers attempted to continually track information in a centralized location: e.g.
In a diary and field study of web tasks, tasks that required multi-sessions were common: 33% of web sessions involved at least one long-running task .
Users wanted more support for managing their tasks between sessions, restoring viewed pages, managing information associated with a task, and cleaning up content after completion.
Unfortunately, knowledge workers, such as programmers, face a different set of problems than previously studied.
For example, many of the tasks previously studied by Bellotti involved managing a high volume of prospective tasks that could often be individually resolved with short-term activities or delegation.
Many of the tasks were also typically associated with requests from clients or office mates; a factor likely contributing to the success of the email-centered approach.
However, software developers are instead assigned a low volume of highly complex work items from a smaller network of people.
Email-centered approaches would not be as likely successful for programming tasks.
Like web tasks, programming tasks often involve long periods of investigation, but with several key differences: the documents are with more structure and are usually more complex, the documents are actively edited by the programmer and other teammates, and where searching on the web potentially is asking every expert on a subject, much programming knowledge is tacit and only available from other busy co-workers.
While several previous studies have documented the fragmented nature of software developers' work, there is no existing survey of the strategies developers use to resume interrupted tasks.
We wanted to conduct a survey that would help us prioritize the conditions we would later test in the lab.
Because the number of interesting conditions is too large to test exhaustively, we wanted to determine one experimental condition to represent current practice  and another to represent developers' preferred treatments.
Overall, we find general agreement with the external survey and internal survey, but only report the internal results for this paper.
As we were primarily interested with professional software development, we selected our population from full-time software developers - excluding interns or roles such as testers or project managers.
We also excluded developers that had been recently surveyed by our research group to avoid oversampling.
Respondents were compensated by a chance to win a $200 gift certificate.
From our participant pool, we randomly sampled 2,000 developers and invited them to participate through email.
Participants answered fifteen fixed- and open-response questions about interruptions.
The participants were asked to describe in detail the cost of interruptions, the steps they took to prepare for an interruption, the resumption strategies they used, factors that made resumption difficult, and feedback on future tools.
We drew the selection of future tools from current research proposals for improvements to programming environments and wanted to determine if programmers were primarily interested if tools help them manage task state or tools augment cues within the programming environment.
Task is well-defined and includes some details of code implementation.
Purpose of task is clear, but does not include plan on how to code it.
Task broad in scope and needs to be refined into many subtasks.
Task tracking Do you take notes to track your progress in programming tasks, for example, notes on paper, sticky notes, OneNote pages, documents in Notepad, etc.?
Leave a reminder cue such as text selection or window.
The results are as follow: We present our findings of typical work practices of our participants in Table 1.
Finally, we obtained ratings of proposed tools as shown in Table 2.
Negative factors included both commonly known aspects of tasks: complexity, concreteness, completeness; and factors specific to software development: low understanding of code, number and size of artifacts, and difficulty setting up and reproducing state.
The participants' free responses about tracking tasks indicate that note taking is by far the most prevalent practice for managing knowledge about a task.
Taking personal notes about tasks was often necessary because the originally assigned task was often vague or required many unspecified subtasks to accomplish.
The participants consistently reported using a mix of media to record notes, including the bug tracking system , the note-taking product Microsoft OneNote, the source code itself, as well as traditional paper media.
The choice of media often reflects whether the task is long-term and/or shared.
Several participants described their personal working style: I track my progress in OneNote, but small issues that I notice and don't want to forget frequently end up as post-it notes or emails to myself.
I'd like to be more consistent about where these things go.
Paper if personal tasks, or notes in Project Studio if public/shared, etc.
Steno Pad and Post Its - Lots and lots of Post Its.
For self-interruptions, the participants typically try to reach a breakpoint, save and prune their working context, jot down high-level notes about outstanding issues, and leave markers in the code.
When participants anticipate a short interruption or are pressed for time, they typically use a more light-weight strategy by leaving the necessary context visible when they return to work with a quick note in the code.
Here are how some participants suspend their working state: Write a short note of the next one or two steps to do.
Save my work and leave one or more windows open at the tasks to be done.
I use comments and TODO's in my code, coupled with a precise reminder of where I am in my notebook.
Several participants expressed frustration about the ineffectiveness of note taking: I take notes on random scraps of paper.
Sometimes I refer to them again, but often they migrate to odd corners of my office where they are never looked at again,
When I don't throw the notes away I invariably leave them at home and then I don't have them at the office the next day.
When returning to a programming task, notes, if available, and task description were commonly re-read to restore a high-level sense of the task.
A common strategy was to navigate the source code to restore working state: participants mentioned how they attempted to work their way backward in time and task and formulate the next step before returning to the task.
However, many times simply navigating was insufficient to restoring working context; participants would often have to use tools to find the recent changes to code.
Review any notes left and then re-read the recent changes to the project.
Not only does this get me back in the frame of mind to work on the project, I also find a good number of logic bugs.
I try to remind myself what it was that I was working on and continue where I left off.
If I'm don't remember, I'll run the app and look at the code diff in order to see what state it was in before I left it.
The developers' ratings in Table 2 are notably consistent in what help they want when resuming tasks.
The top four choices show that they want to see a summary of the content that they edited or inspected before the interruption, whether it is shown from recent changes , in concise form , from recent locations , or organized by actions .
Based on these ratings, we designed one of our experimental conditions to show the content of a developer's activities.
Our base condition consists of note taking alone, representing current practice.
In the other two conditions, the subjects supplemented their note taking by reviewing two different environmental cues that summarize their activities before interruption.
The first of these cues is based on Mylyn, the most widely used research tool for developer task management; the second is based on developers' rating of task resumption features from our preliminary study.
Our controlled study uses a within-subject protocol to allow subjects to compare the three conditions, as well as to mitigate differences due to subjects' varying programming and problem solving skills.
The two experimental cues feed from the same interaction log of developer activities and are shown in separate windows in the Microsoft Visual Studio 2008 development environment.
The two cues, shown in Figure 1, differ only in how the developer's activities are presented.
The first, called the degree-of-interest  treeview, consists of a treeview of names of the program's parts, namely, its projects, files within projects, types within files, members within types.
In the style of Mylyn, these are filtered by a degree-of-interest model over recently visited or edited source code.
The DOI model uses three levels: unvisited parts of the code are in gray, occasionally visited parts are in normal font, and often visited parts are in black boldface.
The second cue, called the content timeline, shows a chronologically sorted list of the developer's activities .
A code selection is presented as the text that was selected , a code insertion is shown with the new code in green, and a code change is shown as a pair of before and after text.
In both cues, clicking on a program part causes the editor to navigate to the corresponding part.
For our tasks, we used source code from three simple games .
The games are C# implementations of classic arcade games.
Our motivation for using these games was based on the familarity games offer and the nontrivial complexity of game source code.
Further, we were assured from our previous user studies we conducted with Tetris and pilot studies that tasks involving these games were challenging yet feasible.
Each subject started with a warm-up period in which the experimenter demonstrated the DOI treeview cue and content timeline cue.
Then, each subject ran a small application that we provided to coordinate the subject's activities over the three programming tasks, shown in Figure 2.
For each task, the application automatically interrupted the subject several minutes after beginning the task, as described below.
At the point of interruption, the subject would review the cue for that task  and take notes, for up to one minute.
The application would then start the subject on the next task.
After all three tasks were interrupted, the application then asked the subject to resume each task, in turn.
Upon resuming a task, the subject was given the opportunity to review that task's cue  and his/her notes.
The subject had up to 20 minutes to complete the task , with an additional 5 minutes, if the subject requested it.
In short, the order of activities was this: 1.
9. start Tetris; get interrupted and review with condition 1; start Pacman; get interrupted and review with condition 2; start Space Invaders; get interrupted and review with condition 3; finish Tetris, resuming with condition 1; finish Pacman, resuming with condition 2; finish Space Invaders, resuming with condition 3;
Change the game so that hitting the space key during game play causes the current figure to fall immediately as far down as it can.
This feature spares the player from having to hit the down arrow key many times in succession.
The figure's fast fall does not need to be animated.
The figure can simply disappear from its current position and reappear at the bottom of the grid.
Mylyn also includes the ability to decay the DOI model as time passes and segregate different task contexts.
For our study, we did not implement these aspects because the task duration was not long enough to trigger the time-decay and we were already isolating workspaces for the different tasks.
The two cues differ in two dimensions.
First, the DOI treeview presents program parts by name ; the content timeline presents program parts by content .
Second, the DOI treeview organizes the developer's activities by the code's structure; the content timeline organizes the activities by time.
These dimensions are independent, so two other cues are possible, namely, content changes shown in a treeview and program names shown in a timeline.
Testing two other conditions, however, would have made the experimental sessions too long and fatiguing.
Hence we tested opposite corners of this two-by-two design quadrant in the hopes of maximizing the measured effects.
Fifteen professional programmers , average age of 39 years , participated in this study for receipt of 2 copies of Microsoft software.
The programmers were screened and then selected based on a series of profile questions.
The profile questions were designed to recruit developers experienced with the development tools and environment used in the study .
In addition, we screened developers for experience with debugging and modifying the code of other developers and working in teams of at least 3 people.
Each subject was given the three conditions  exactly once.
We counterbalanced the conditions across subjects to account for ordering effects.
Each session ended with a questionnaire to rate the two cue and gather general feedback.
To provide use a consist and automated mechanism for interrupting the subjects, we used the following criteria: 15 seconds after a non-comment edit, after more than three noncomment edits, or after a twelve-minute timeout if no changes were made.
We based these criteria on the factors Fogarty previously found to be associated with inopportune moments for interruption  and the nature of our tasks.
The solutions for the programming tasks typically required changes to multiple parts of the source code.
By setting the interruption point to be several moments after making a change, upon returning, the developer must ensure the change is completed correctly and then recall the next steps and relevant parts of code needed for the next change.
Each subject was run individually in our user study laboratory.
An experimenter was present for the entire session.
The experimenter instructed the subjects to the goals of the study.
Subjects were told that we were interested in how they would multi-task between several programming tasks and how they utilized different tools given to them.
In addition, we stressed that we were not interested a perfect solution, but in completing as much of task as possible.
Each programming task was to add a small feature to each game: 1.
Tetris: Change the game so that hitting the space key during game play causes the current figure to fall immediately as far down as it can.
This feature spares the player from having to hit the down arrow key many times in succession.
The figure's fast fall does not need to be animated.
The figure can simply disappear from its current position and reappear at the bottom of the grid.
Pacman: In the existing game, if a power pellet is collected, the ghosts turn blue, slow down, and can be eaten for points.
Change the game so that if a power pellet is collected, the ghosts instead freeze in place until the timer runs out.
Space Invaders: In the existing implementation, when the player fires a shot, it either hits an enemy or reaches the top of the screen.
Change the game so that whenever the player fires a shot that misses an enemy, a new enemy is created.
The new enemy is placed in the lowest row of an existing enemy, filling in an empty position if possible.
If all enemies positions are filled, no new enemy is created.
We used separate games, with separate code bases, for the tasks to keep the subject from polluting one task with the changes from another.
For example, if the subject changed the Tetris code to the point where it would no longer compile, this did not prevent the subject from making progress on the next two tasks.
The subject would have to fix the broken compilation after resuming the Tetris task.
Using different code bases for all three tasks also ensured that there was no learning effect across tasks.
Finally, the use of three unfamiliar code bases served to overload the subject's memory, maximizing the detrimental effect of interruption.
To better understand why some subjects failed to complete the tasks in the allocated time, we categorize the type of error that lead to the failure: 1.
Problem solving: The subject had all the pieces, he or she were stuck on the problem part.
Domain knowledge: The did not understand WinForms, event handler syntax, etc.
Relocation: The subject had difficulty relocating relevant parts of the code.
Programming: The subject had misunderstandings about the program or the changes he or she made.
Note that we kept the 20-minute deadline "soft" to avoid failures due to arbitrary cut-offs.
The subjects who did not succeed in a task were not close, even after 25 - 30 minutes.
The data in Table 4 categorizes the failures of the seven subjects completing at least one task.
As one example of a programming error, one subject was interrupted in the middle of hooking the space key event for the Tetris task.
When the subject later resumed the task, he completed defining the space key event, but forgot to connect the event with the handler.
The subject moved on to the next part of the task, making the tetris block fall down, and quickly implemented the functionality much faster than other subjects.
However, when the subject tested the solution, the missing association prevented the new feature from working.
The subject spent the remaining 10 minutes fiddling with the logic of the code, without realizing that the subject had simply forgotten to associate the handler with the space key event.
This was the only task the subject failed.
As an example of a relocation error, a subject was interrupted in the Space Invaders task in the notes-only condition.
The subject located the code for resetting the bullet.
Next, the subject needed to find out how to create a new invader - but was interrupted during the search.
The subject took notes for the search, but did not jot down the code location for resetting the bullet.
After resumption, the subject found how to create an invader,and now needed to return to the previously found code for resetting the bullet.
Unfortunately without sufficient notes or cues to rely on, the subject took 5 minutes to relocate this code.
The subject was frustrated that they knew what code they wanted, but could not find its location:
I remember finding that code, I just can't remember where it is!
Unfortunately, by the time the subject had reached the code, the subject had used up most of their time and could not complete the task within the allocated time.
Experts could ward against these problems by proactively using markers, but might fail to do so when the necessary code is several subtasks away or when they did not anticipate being sidetracked on a subtask.
To understand the cost of resuming tasks in the three conditions, we used two measures of lag: 1.
Resumption lag: the time between clicking the "play" button to restart a task and the first event initiated in the IDE.
Edit lag: the time between clicking the "play" button and the first code edit.
The resumption lags were quite similar in all conditions.
The mean resumption lags  for each condition were: 20 sec, for the DOI treeview; 21 sec, for the content timeline; and 23 sec, for notes-only condition.
These differences are not statistically significant by a one-tailed t-test.
For edit lag, we took out the 5 subjects that did not complete any tasks because for at least one task, these subjects did even not make an edit after resuming their task.
The edit lags  for each condition, in minutes and seconds, were: 2:30, for the DOI treeview; 3:26, for the content timeline; and 4:28, for notes-only.
These differences are also not statistically significant by a one-tailed t-test.
After the tasks were over, we asked the subjects to rate, on a 5-point Likert scale, four aspects of the three conditions :  how quickly it helped them resume their tasks ;  how well it reminds them of details from the interrupted task;  how useful they feel it would be after a week ; and  how well they liked it overall.
Their average ratings are shown in Figure 3.
Their ratings are notably consistent: in all four areas, they rated the content timeline higher than note taking and note taking higher than the DOI treeview.
These differences are statistically significant by one-tailed t-test .
All subjects took some form of notes.
We categorize notetaking into two categories: situated: The notes are placed within the source code and unsituated: The notes are written on paper or electronically within a notepad.exe window.
Most of the subjects' notes were unsituated .
The content of the notes would generally refer to either actions and objectives  or specific code symbols .
During task suspension, subjects wrote down several types of information.
Several subjects would summarize the task description into a simple one-line sentence  or summarize what they had previously worked on.
Most subjects tended to write notes about the most immediate subtask and would neglect to record other locations needed later for the task, that is they would tend to repeat the last location they were working on, but not where they might need to go next.
Not surprisingly, 65% of the lines of unsituated notes would refer to code symbols, while only 14% of the lines of situated notes refered to code symbols.
This suggests that when subjects write unsituated notes on paper, they need to spend several lines of text recreating the context in order to adequately record their note.
The types of code symbols subjects wrote varied in the amount of code referred to: files ; methods ; variables ; code expressions ; or line numbers .
When asked what they liked or disliked about the presentation of the cues, the subjects enjoyed the bolding of items in the treeview and the presentation of the code difference in the content timeline.
Several subjects felt the DOI treeview was not granular enough and the method names was not as effective for triggering their memory about tasks.
One subject said during the task, " does not show me where I just was.
I would not remember this location if I had to come back in ten minutes".
Another subject suggested the DOI treeview could be improved by distinguishing between items that were navigated to versus items that were edited.
Subjects felt the cues would offer interesting opportunities to complement their future note-taking habits.
In our survey of developers, the developers said they placed temporary placeholders in the code that would be removed as soon as they returned to work.
Most subjects enjoyed the synergy between the content timeline and TODO notes because it would be an automated place to view scattered notes in one place.
They also mentioned wanting to directly enter or associate persisted TODO notes with items in the content timeline because many TODO personal comments are deleted right before checking in code.
Subjects also talked about how they would change some of what they wrote down: I wouldn't have to write down the location, just what needs to be done.
Subjects also had many general suggestions and ideas for in-
Better support for filtering and different options for clustering the content ; quick gestures to select, save, and tag snippets of code that could be published to a personal repository and in the content timeline; and pin down or remove content from the content timeline.
Finally, subjects enjoyed using the content timeline during the feedback portion of the study to explain their thought processes and approach to the recently completed task.
They were excited about the possibilities for using this to facilitate communication with other team members about their work.
Our focus in this study was to measure differences in the cues.
Finally, an additional threat to external validity is the nature of programming tasks we selected.
Programmers encountering new code may not be able to as effectively utilize memory cues such as the DOI treeview because they are not as familiar with the specific names within the program and they have less opportunity to explore.
However, our tasks are representative of many maintenance and bug fix tasks where developers need to understand someone else's code enough to make a corrective change.
Subjects used the cues in different ways.
For the DOI treeview, subjects treated them like tabs in a multi-document interface.
That is, when they could not remember which method contained the code they had in mind, they would use the names as information scent and click from one to another until they found the desired code.
Many subjects with the content timeline would use it in two stages.
They looked at the most recent entries for context, completing any work within their open document.
Then, they would return to the activity timeline to rewind further back to review their previous actions before their last stopping point.
From this review, subjects would often see the next place they wanted to return to.
Although our study found no difference between the DOI treeview and content timeline, subjects rated the DOI treeview much lower.
One explanation is the code was new to them, and therefore they were less familiar with the symbol names with which the DOI treeview refers to the code; they preferred the content timeline because it presents the code directly as they saw it in the editor.
If the subjects had been previously familiar with these code bases, their subjective ratings might be different.
Although subjects did use the cues when resuming tasks, they did not use them much when preparing to suspend tasks.
Instead, subjects focused on reaching a good stopping point or leaving a quick note.
This suggests notes remain an important mechanism for suspending interrupted tasks.
We have presented an investigative study that provides new insight into how programmers currently recover from interruptions and a controlled study that evaluates how cues could assist resumption of programming tasks.
The results provide a strong motivation for the need for tool support for helping developers resume tasks.
Today, note taking is the most common way for developers to cope with task suspension and resumption, yet subjects in the note-taking condition had half the success rate as those using the automatic task resumption cues.
The two cues performed well, but subjects preferred the content timeline over the DOI treeview.
This has important implications for knowledge workers beyond developers.
The DOI treeview works well for source code, where the documents contain a hierarchy of named parts, but may not work as well for unstructured documents.
The content timeline, on the other hand, does not take advantage of the code structure and would work equally well for unstructured documents.
For example, office workers could use a content timeline to see changes to a spreadsheet by showing formula changes and cell changes in the timeline.
Hence, using the content timeline for task resumption may be as effect for general knowledge workers as it is for developers.
Presenting information in an episodic fashion can also be useful for communicating work to others or for providing context when handing off a task from one person to another.
For example, Mylyn already allows developers to store DOI trees with work items in bug database, as a form of guidance for the next developer who takes on the work item.
To provide a similar capability for the content timeline creates privacy concerns, however, since the timeline contains the history of work activities.
A developer, for example, may not want a coworker to see his "mistakes" when viewing his timeline.
A persistent form of the content timeline would have to be designed with these privacy concerns in mind.
We choose a time limit for tasks that made it possible to conduct our experiment within a 2 hour time frame without exhausting participants.
However, this time limit may have excluded less experienced participants who need much longer time to complete the tasks.
Our study has focused on experts, many of which could complete the tasks within a few minutes, and may not generalize to novice users.
We believe that the minute to prepare for interruption that we gave each subject makes our study unrepresentative of interruptions without warning but adequately representative of interruptions with warnings and self-interruptions, both of which frequently occur among professional developers .
We included this minute to prepare, despite the threat, because previous psychology studies show that having a pe-
E. M. Altmann and J. G. Trafton.
Task interruption: Resumption lag and the role of cues.
In Proceedings of the 26th annual conference of the Cognitive Science Society, 2004.
What a to-do: studies of task management towards the design of a personal task list manager.
In CHI '04: Proceedings of the SIGCHI conference on Human factors in computing systems, pages 735-742, New York, NY, USA, 2004.
Understanding memory triggers for task tracking.
In CHI '07: Proceedings of the SIGCHI conference on Human factors in computing systems, pages 947-950, New York, USA, 2007.
E. Cutrell, M. Czerwinski, and E. Horvitz.
Notification, disruption and memory: Effects of messaging interruptions on memory and performance.
M. Czerwinski, E. Horvitz, and S. Wilhite.
A diary study of task switching and interruptions.
In CHI '04: Proceedings of the SIGCHI conference on Human factors in computing systems, pages 175-182, New York, NY, USA, 2004.
R. DeLine, M. Czerwinski, B. Meyers, G. Venolia, S. Drucker, and G. Robertson.
Code thumbnails: Using spatial memory to navigate source code.
In VLHCC '06: Proceedings of the Visual Languages and Human-Centric Computing, pages 11-18, Washington, DC, USA, 2006.
R. DeLine, M. Czerwinski, and G. Robertson.
Easing program comprehension by sharing navigation data.
Examining task engagement in sensor-based statistical models of human interruptibility.
In CHI '05: Proceedings of the SIGCHI conference on Human factors in computing systems, pages 331-340, New York, NY, USA, 2005.
T. Gillie and D. Broadbent.
H. M. Hodgetts and D. M. Jones.
Contextual cues aid recovery from interrruption: The role of associative activitation.
Investigating the effectiveness of mental workload as a predictor of opportune moments for interruption.
S. T. Iqbal and E. Horvitz.
Disruption and recovery of computing tasks: field study, analysis, and directions.
In CHI '07: Proceedings of the SIGCHI conference on Human factors in computing systems, pages 677-686, New York, NY, USA, 2007.
B. M. Kay and C. Watters.
In CHI '08: Proceeding of the twenty-sixth annual SIGCHI conference on Human factors in computing systems, pages 1187-1196, New York, NY, USA, 2008.
M. Kersten and G. C. Murphy.
Using task context to improve programmer productivity.
In SIGSOFT '06/FSE-14: Proceedings of the 14th ACM SIGSOFT international symposium on Foundations of software engineering, pages 1-11, New York, NY, USA, 2006.
Eliciting design requirements for maintenance-oriented ides: a detailed study of corrective and perfective maintenance tasks.
Information needs in collocated software development teams.
Examining the nature of fragmented work.
In CHI '05: Proceedings of the SIGCHI conference on Human factors in computing systems, pages 321-330, New York, NY, USA, 2005.
Comparison of four primary methods for coordinating the interruption of people in human-computer interaction.
Y. Miyata and D. A. Norman.
Psychological issues in support of multiple activities.
In D. A. Norman and S. W. Draper, editors, User Centered System Design: New Perspectives on Human-Computer Interaction, pages 265-284.
The efffect of frequent versus infrequent interruptions on primary task resumption.
In Proceedings of the Human Factors and Ergonomics Society 48th Annual Meeting, 2004.
B. O'Conaill and D. Frohlich.
Timespace in the workplace: dealing with interruptions.
G. Oleksik, M. L. Wilson, C. Tashman, E. Mendes Rodrigues, G. Kazai, G. Smyth, N. Milic-Frayling, and R. Jones.
Lightweight tagging expands information and activity management practices.
In CHI '09: Proceedings of the 27th international conference on Human factors in computing systems, pages 279-288.
N. Oliver, M. Czerwinski, G. Smith, and K. Roomp.
Relalttab: assisting users in switching windows.
C. Parnin and C. G org.
Building usage contexts during program comprehension.
In ICPC '06: Proceedings of the 14th IEEE International Conference on Program Comprehension, pages 13-22, 2006.
C. Parnin and S. Rugaber.
Resumption strategies for interrupted programming tasks.
In ICPC '09: Proceedings of the 17th IEEE International Conference on Program Comprehension, Washington, DC, USA, 2009.
G. S. Patrick, P. Baudisch, G. Robertson, M. Czerwinski, B. Meyers, D. Robbins, and D. Andrews.
Caad: an automatic task support system.
In CHI '07: Proceedings of the SIGCHI conference on Human factors in computing systems, pages 687-696, New York, USA, 2007.
G. Robertson, E. Horvitz, M. Czerwinski, P. Baudisch, D. R. Hutchings, B. Meyers, D. Robbins, and G. Smith.
Scalable fabric: flexible task management.
In AVI '04: Proceedings of the working conference on Advanced visual interfaces, pages 85-89, New York, NY, USA, 2004.
Safer and G. C. Murphy.
Comparing episodic and semantic interfaces for task boundary identification.
In CASCON '07: Proceedings of the 2007 conference of the center for advanced studies on Collaborative research, pages 229-243.
Navtracks: Supporting navigation in software maintenance.
In ICSM '05: Proceedings of the 21st IEEE International Conference on Software Maintenance, pages 325-334, Washington, DC, USA, 2005.
Windowscape: a task oriented window manager.
In UIST '06: Proceedings of the 19th annual ACM symposium on User interface software and technology, pages 77-80.
Preparing to resume an interrupted task: effects of prospective goal encoding and retrospective rehearsal.
How tagging helps bridge the gap between social and technical aspects in software development.
R. van Solingen, E. Berghout, and F. van Latum.
Interrupts: Just a minute never is.
