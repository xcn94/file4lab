This paper first describes several predictive algorithms from diverse areas of computer science that can be used to predict upcoming user actions.
We then explain the key objectives for this type of algorithm - to predict accurately, and to provide stability so that users can anticipate where items will be located in interfaces that provide access to the algorithm's predictions.
We explain how AccessRank combines two previous algorithms and adds new components to incorporate time of day information and to enhance stability.
Then, we compare AccessRank's performance with that of many preexisting algorithms by running simulations using three sets of log-file data extracted from real user activities: command use, web navigation, and window switching.
Finally, we discuss issues with deploying AccessRank in real interfaces.
We introduce AccessRank, an algorithm that predicts revisitations and reuse in many contexts, such as file accesses, website visits, window switches, and command lines.
AccessRank uses many sources of input to generate its predictions, including recency, frequency, temporal clustering, and time of day.
Simulations based on log records of real user interaction across a diverse range of applications show that AccessRank more accurately predicts upcoming accesses than other algorithms.
The prediction lists generated by AccessRank are also shown to be more stable than other algorithms that have good predictive capability, which can be important for usability when items are presented in lists as users can rely on their spatial memory for target location.
Finally, we present examples of how real world applications might use AccessRank.
Many forms of interaction with computer systems are repetitive - we use the same commands , visit the same websites , return to previously visited document regions , and so on.
To improve the efficiency of accessing previously used items, many diverse interactive techniques and systems have been developed, with examples including command histories , web page recency lists , scrollbar marks showing previous areas of document use , and menu adaptations that emphasise probable upcoming selections .
While there are plentiful examples of research and commercial systems that provide support for retrieving previously used data, there is much less on the design and evaluation of the underlying algorithms that support the predictions presented to users .
Improving the performance of these algorithms would have a strong impact on many areas of interaction.
Several areas of work influence our research, including general information retrieval, recommender systems, search, and caching algorithms.
For brevity, we focus on summarising the algorithms that can be adapted for predicting upcoming actions based on previous actions, as follows: Most Recently Used  and Most Frequently Used  calculate ranks based solely on recency or frequency, respectively.
Split Recency and Frequency   select n items with MRU, then the rest with MFU.
Combined Recency and Frequency  , used originally for cache management, considers every past access of an item.
It is calculated by Equation 1, where wf is the item's weighting, n is the number of past accesses, t is the current time and ti is the time of access i .
In our testing p = 2 and  = 0.1 performed best.
To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee.
The Adaptive algorithm filters menus in software such as Microsoft Office 2000 .
Item counts are incremented when selected and decremented after multiple sessions of disuse.
The Places Frecency algorithm   is used in Firefox to order URL suggestions when typing a web address.
The last ten accesses of each item are placed in time-based buckets with different weights based on recency.
The switching threshold improves stability.
Consider items A and B at positions rA < rB in the previous prediction list.
Pairwise comparisons between item weights are made during sorting to generate a new prediction list.
If A and B are compared and their new weights wA and wB are such that wB > wA , then B will only be ranked higher than A if wB > wA +  , where   0 is an AccessRank parameter.
This comparison is not transitive, however it is deterministic with a given sorting algorithm.
In our implementation we used merge sort.
AccessRank goals are twofold: first, to accurately predict the next action based on past ones; and second, to maximise list stability.
The importance of prediction accuracy is obvious, but the need for stability is also important because it allows users to learn item locations over time, facilitating expertise with the interface used for list presentation .
AccessRank has three components, described below: AccessRank Score, which combines the stability of CRF with the accuracy of Markov; Time Weighting, which weights items based on the current time and day; and Switching Threshold, which improves stability.
Computing AccessRank is fast, as its model can be updated in O time, all scores can be updated in O time, and predictions made in O time.
A raw AccessRank score wn is calculated for each previously accessed item using Equation 3. wmn is the Markov weight, wcrfn is the CRF weight with p = 2 and  = 0.1 and wt is a time weighting.
The parameter  > 0 can be adjusted based on whether accuracy or stability is more important and determines the blend between the Markov and CRF algorithms.
We compared performance of these algorithms by analysing their predictive capability and stability for each successive action by each of many users recorded in several log datasets.
The log datasets were collected from previously published studies conducted by other researchers, summarised in Table 1.
The log files were first converted to a standardised format, consisting of a series of Visit, Addition and, in some domains, Removal events.
Then, simulations were run over each file, with each algorithm generating a prediction list prior to each Visit event, and the other events used to update the set of possible items to revisit.
The prediction list was then compared with the actual logged Visit event.
Stability was also continually calculated.
For the window switching logs, only user generated switches sustained for more than a second were considered, and we processed the raw logs as both window and application switching.
We process the web browsing logs with full URLs and with domains only, where consecutive accesses on the same domain were collated into one visit.
The command-line logs were processed as logs of full command lines, and as logs of just the first command from each line.
The time weighting wtn gives higher weighting to items that have historically been more frequently accessed at the current time of day or day of week.
From informal observations, we have observed that many aspects of interaction are temporally predictable, for example habitually accessing a news webpage on arrival at work.
Let ch be the current hour of the day.
For item n, let h be the ratio of the number of previous accesses of n in hours in the range  compared to the average number of previous accesses of n for a three hour slot.
Similarly, let d be the ratio of the number of previous accesses of n on the current day of the week to the average across all days of the week.
We used two types of measures to assess the algorithms' performance: accuracy measures, which assess prediction accuracy; and stability measures, which assess prediction lists variability over time.
These include the Average Rank of revisitations in prediction lists, and the percentage of correct predictions .
We also analyse how the latter is affected by accepting matches in the top k predicted items rather than just the top item, and by providing fixed length typed prefix `hints' of a series of characters to the algorithm, which is common in interfaces such as Firefox's AwesomeBar: for example, cnn.com might become the first recommendation after typing `c'.
In their analysis of stability measures, Webber et.
Weightedness refers to measures that give greater importance to items at certain ranks .
Conjointness refers to whether or not two lists contain the same items : they are conjoint when membership is the same, and non-conjoint otherwise.
We are most interested in top-weighted non-conjoint measures, as people tend to look at the top of a list, and the set of items being ranked changes over time.
We consider three stability measures: Average overlap  and rank-biased overlap  , and Learnability .
AO and RBO are both top-weighted nonconjoint measures.
Learnability , is estimated as "one minus the average distance that items move as a proportion of half of the total menu length".
While this is non-weighted, we used k = 10, focusing list comparisons on the most important items.
Items that were in only one list were treated as having moved half the total menu length.
For all stability measures, we calculated the average similarity score across comparisons of every pair of consecutive lists for each log-algorithm pairing in the simulation.
The log-based analysis investigates performance by comparing the algorithms' predictions before each activity with the actual activity recorded in the logs.
Several measures of prediction accuracy 
The factors under study are as follows:
Web browsing logs, however, often require more, in order to determine which page within a domain is targeted.
The three stability measures  produced very similar results.
MFU was the most stable algorithm, followed by Places Frecency, with Markov least stable.
An ideal algorithm will give accurate predictions and high stability.
Figure 3 graphs Stability  against Average Rank and Percentage Revisitations Predicted.
The latter is especially important as the top result is most useful - interfaces provide rapid `press to confirm' access for such items.
AccessRank performs best in this important category, but it also matches the best algorithms in both accuracy and stability.
Both graphs illustrate the flexibility of AccessRank, in that it can be tailored to optimise either accuracy or stability as required, while still outperforming other algorithms.
AccessRank  has the highest Percentage Revisitations Predicted score with 41% overall .
All AccessRank configurations with  = 0 or 0.2 performed best.
It also had the lowest average rank of 10.3 , followed by Markov .
Relatively short prediction lists contain most revisitations.
Figure 1 shows this for three datasets that incorporate all log data and illustrates both AccessRank's best and worst case accuracy.
While AccessRank and Markov generally perform best, there is variation between domains - Markov performs best for web pages; AccessRank for Unix commands.
We also analysed how the algorithms perform when usertyped `hints' are given .
Normally, just a few char-
When stability is unimportant, values of  give the best top prediction accuracy, while  may be better if the average rank is the primary goal.
When stability is particularly important, high values for both parameters can be used, e.g.
AccessRank could be incorporated in interfaces for any domain containing patterns of reuse.
For example, a file browser could use an AwesomeBar-like interface that suggests files based on filename portions, eliminating the need to traverse hierarchies.
A separate section could display the top weighted items in the file hierarchy subtree rooted at the current location.
Window switching interfaces could highlight windows that are more likely to be acquired, to help users find relevant windows without confusing them by ordering items unpredictably.
Many other domains could also benefit.
While AccessRank is a powerful algorithm, there are still improvements that could be made.
The time weighting is based exclusively on the absolute time, but might be more effective if, for example, events were considered relative to the computer's first use each day.
Location awareness could be incorporated; for example, if a user is in range of their work wireless network, accessed items will differ from when in range of their home network.
Furthermore, while AccessRank is domain-independent, domain specific improvements could further improve its performance; for example, for file browsing past access methods could be considered , as could the interaction between hints and path components.
We have described AccessRank, a customisable revisitation prediction algorithm that is more accurate than existing algorithms while also producing stable results.
Performance simulations over a range of datasets confirm its applicability in a wide variety of contexts, and demonstrate that different parameters can be used to tailor AccessRank to specific situations and design goals.
In ongoing and further work, we will deploy the AccessRank algorithm in a range of applications and empirically assess its performance.
